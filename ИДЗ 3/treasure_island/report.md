# Отчёт по индивидуальному заданию №3  
по дисциплине «Архитектура компьютера и операционные системы»

**Выполнил:**  
Бочкарев Максим Андреевич, БПИ-245-2

**Вариант:** 32  
**Задача:** Остров сокровищ

---

## 1. Условие задачи (вариант 32)

> Шайка пиратов под предводительством Джона Сильвера высадилась на берег Острова Сокровищ. Несмотря на карту, местоположение клада неизвестно, поэтому искать приходится на ощупь. Сильвер делит остров на участки, а пиратов — на группы. Каждая группа ищет клад на своём участке и докладывает о результате. Количество участков превышает число групп. Требуется создать многопроцессное приложение с управляющим процессом, моделирующее действия Сильвера и пиратов. Каждый процесс — отдельная группа или управляющий.

---

## 2. Сценарий задачи и архитектура решения

- **Управляющий процесс (manager)** делит остров на участки, создаёт задания и IPC-объекты (shared memory, семафоры, очереди сообщений).
- **Пираты (pirate)** — отдельные процессы, получают задания из общей памяти, ищут клад, докладывают о результатах через очередь сообщений.
- **Наблюдатели (observer)** — отдельные процессы, получают все сообщения о ходе поиска и выводят их в консоль.
- Все процессы запускаются независимо, число пиратов и наблюдателей задаётся аргументами или скриптом.

---

## 3. Краткое описание реализации

- **IPC:**  
  - Именованные POSIX семафоры (`sem_open`), POSIX shared memory (`shm_open`), POSIX message queue (`mq_open`).
  - Для поддержки нескольких observer реализован broadcast: manager создаёт несколько очередей сообщений, pirate пишет во все очереди, каждый observer читает свою.
- **Завершение:**  
  - Все процессы ловят SIGINT/SIGTERM, корректно завершают работу, освобождают ресурсы (unlink/unmap/close).
- **Удаление IPC:**  
  - Очистка реализована в manager.cpp (cleanup) и в скрипте run.sh.
- **Аргументы:**  
  - manager: `./manager <M> <G> <N_observers>`
  - pirate: `./pirate <id>`
  - observer: `./observer <observer_id>`
- **Вывод:**  
  - Каждый процесс пишет в свою консоль, observer отображает все события.

---

## 4. Способ запуска и порядок

Рекомендуется использовать автоматический скрипт `run.sh`:

```bash
bash ./run.sh
```

- Скрипт очищает IPC-объекты, собирает проект, запускает manager, несколько observer и пиратов.
- Количество observer задаётся переменной `N_OBS` в скрипте.
- Все процессы запускаются независимо.

---


## 5. Результаты работы

- В консоли каждого observer отображаются все события поиска: кто и какой участок проверил, кто нашёл клад.
- После нахождения клада все процессы корректно завершают работу.
- Пример вывода:
  ```
  [observer 1 pid 1234] listening...
  PIRATE 2 (pid 4321) searched 1 (220 ms)
  PIRATE 5 (pid 4324) FOUND TREASURE at 3 (478 ms)
  ...
  ```

---

## 6. Выводы

В ходе выполнения задания реализовано многопроцессное приложение, моделирующее коллективный поиск клада с использованием POSIX IPC. Решение полностью соответствует требованиям для максимальной оценки (10 баллов): поддерживается независимый запуск процессов, корректная синхронизация, интеграция информации наблюдателями, возможность подключения нескольких observer с получением всех событий.

---

**Приложения:**  
- Исходный код: manager.cpp, pirate.cpp, observer.cpp, run.sh  
- Скриншоты работы: ![alt text](<Снимок экрана от 2025-11-30 18-05-24.png>)

---

