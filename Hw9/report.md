# Передача данных между процессами с помощью сигналов в Linux

## Введение

В рамках лабораторной работы реализована передача 32‑битного целого числа между двумя процессами — `sender` и `receiver` — с использованием пользовательских сигналов `SIGUSR1` и `SIGUSR2`. Идея: представить число в двоичном виде и передавать каждый бит отдельным сигналом.

## Цель работы

- Изучить механизм взаимодействия процессов (IPC) на уровне сигналов.
- Реализовать регистрацию обработчиков сигналов.
- Передать число побитно через `SIGUSR1` / `SIGUSR2`.
- Восстановить число на стороне получателя и обеспечить синхронизацию.

## Принцип работы

Каждый сигнал кодирует один бит:
- `SIGUSR1` — бит 0
- `SIGUSR2` — бит 1

Передача идёт от старшего бита (MSB) к младшему (LSB). Оба процесса обмениваются PID — отправитель знает PID получателя, а получатель PID отправителя (если необходима подтверждающая логика).

### `receiver`

1. При запуске выводит свой PID.
2. Получает (или вводит) PID отправителя.
3. Ожидает 32 сигнала.
4. По каждому сигналу собирает соответствующий бит и восстанавливает 32‑битное целое.
5. После завершения вывода — отображает полученное число.

### `sender`

1. При запуске выводит свой PID.
2. Получает PID получателя.
3. Запрашивает у пользователя целое число для отправки.
4. Отправляет 32 сигнала: от старшего бита к младшему.
5. Завершает работу.

## Схема взаимодействия

```
sender --SIGUSR1/SIGUSR2--> receiver
```

Каждый сигнал соответствует одному биту (0 или 1).

## Компиляция и запуск (пример)

Сборка:

```bash
g++ sender.cpp -o sender
g++ receiver.cpp -o receiver
```

Запуск `receiver`:

```bash
./receiver
RECEIVER PID: 14329
Enter sender PID: 14315
Waiting for 32 bits...
```

Запуск `sender`:

```bash
./sender
SENDER PID: 14315
Enter receiver PID: 14329
Enter integer to send: 60
Sender finished.
```

## Пример и результат

В примере выше `sender` передаёт число `60`. `receiver` получает ровно 32 сигнала и собирает значение `60`.

### Двоичное представление (32 бита)

Отправленное число: `60`

```
00000000 00000000 00000000 00111100
```

(Биты идут слева направо от старшего к младшему.)

## Замечания по реализации и надёжности

- Сигналы — это простой, но не быстрый и не гарантированно надёжный канал передачи больших объёмов данных. Для одноразовой передачи фиксированного количества битов подходит.
- Между отправкой сигналов полезно вводить небольшую паузу (например, `usleep`) или использовать подтверждения, чтобы избежать потери сигналов при сильной загрузке процессора.
- Для более сложной синхронизации можно применять дополнительные сигналы подтверждения от `receiver` к `sender`.

## Выводы

- Изучены базовые механизмы сигналов в Linux: регистрация обработчиков (`sigaction`), отправка сигналов (`kill`) и обработка сигналов в процессе.
- Реализована передача 32‑битного числа между двумя процессами с использованием `SIGUSR1`/`SIGUSR2`.
- Получен практический опыт побитовой передачи данных и простейшей синхронизации процессов.

---

Если хотите, могу:

- Включить проверку на отрицательные числа и расширение до 64 бит.
- Добавить подтверждающие сигналы для повышения надёжности.
- Отформатировать пример кода `sender.cpp` / `receiver.cpp` и добавить в репозиторий.

